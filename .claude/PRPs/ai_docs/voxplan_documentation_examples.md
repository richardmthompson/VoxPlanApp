# VoxPlan-Specific Documentation Examples

**Practical documentation examples tailored for the VoxPlan codebase**

---

## Overview

This guide provides real-world documentation examples specifically for VoxPlan's architecture, which includes:
- 51 Kotlin files
- MVVM architecture
- Jetpack Compose UI
- Room database
- Daily events and quota management

---

## Database Layer Examples

### Entity Example: DailyEntity

```kotlin
package com.example.voxplan.data.database.entity

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

/**
 * Represents a daily event in the VoxPlan database.
 *
 * Daily events are user-created tasks or activities scheduled for specific dates.
 * Each event can optionally be associated with a quota for tracking progress
 * against user-defined goals.
 *
 * Database Schema:
 * - Table: "dailies"
 * - Primary Key: [id] (auto-generated)
 * - Foreign Key: [quotaId] → quotas.id (CASCADE on delete)
 * - Indices:
 *   - Composite index on (date, quotaId) for efficient date-based queries
 *   - Index on quotaId for join optimization
 *
 * Relationships:
 * - Many-to-One with [QuotaEntity]: Multiple dailies can share one quota
 * - When quota is deleted, all associated dailies are cascade-deleted
 *
 * Data Integrity:
 * - [date] must follow "dd-MM-yyyy" format (validated at repository layer)
 * - [title] maximum length: 100 characters
 * - [isCompleted] defaults to false for new events
 * - [createdAt] and [updatedAt] auto-populated with current timestamp
 *
 * @property id Unique identifier for the event, auto-generated by Room
 * @property date Event date in "dd-MM-yyyy" format (e.g., "10-11-2025")
 * @property title Brief event description, max 100 characters
 * @property description Optional detailed description, nullable
 * @property isCompleted Whether event has been marked as complete
 * @property quotaId Optional reference to associated quota, null for standalone events
 * @property parentEventId Optional reference to parent event for hierarchical events
 * @property createdAt Unix timestamp (milliseconds) when event was created
 * @property updatedAt Unix timestamp (milliseconds) of last modification
 *
 * @see QuotaEntity
 * @see DailyDao
 * @see DailyRepository
 *
 * @sample com.example.voxplan.samples.DatabaseSamples.createDailyEntity
 */
@Entity(
    tableName = "dailies",
    foreignKeys = [
        ForeignKey(
            entity = QuotaEntity::class,
            parentColumns = ["id"],
            childColumns = ["quotaId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["date", "quotaId"]),
        Index(value = ["quotaId"]),
        Index(value = ["parentEventId"])
    ]
)
data class DailyEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    @ColumnInfo(name = "date")
    val date: String,

    @ColumnInfo(name = "title")
    val title: String,

    @ColumnInfo(name = "description")
    val description: String? = null,

    @ColumnInfo(name = "is_completed")
    val isCompleted: Boolean = false,

    @ColumnInfo(name = "quota_id")
    val quotaId: Long? = null,

    @ColumnInfo(name = "parent_event_id")
    val parentEventId: Long? = null,

    @ColumnInfo(name = "created_at")
    val createdAt: Long = System.currentTimeMillis(),

    @ColumnInfo(name = "updated_at")
    val updatedAt: Long = System.currentTimeMillis()
)
```

### DAO Example: DailyDao

```kotlin
package com.example.voxplan.data.database.dao

import androidx.room.*
import com.example.voxplan.data.database.entity.DailyEntity
import kotlinx.coroutines.flow.Flow

/**
 * Data Access Object for daily event database operations.
 *
 * Provides methods for querying, inserting, updating, and deleting daily events
 * from the Room database. All query operations return Flow to enable reactive
 * UI updates - Room automatically requeues and emits new data when the
 * underlying database changes.
 *
 * Threading Model:
 * - Flow queries: Automatically executed on background thread by Room
 * - Suspend functions: Safe to call from main thread, Room handles background execution
 * - No explicit thread handling needed in calling code
 *
 * Query Optimization:
 * - Uses composite index (date, quotaId) for date-based queries
 * - Uses quotaId index for quota-related queries
 * - Uses parentEventId index for hierarchical event queries
 *
 * @see DailyEntity
 * @see DailyRepository
 * @see VoxPlanDatabase
 */
@Dao
interface DailyDao {

    /**
     * Retrieves all daily events for a specific date, ordered by creation time.
     *
     * Returns a Flow that automatically emits a new list whenever any daily event
     * for this date is inserted, updated, or deleted. The UI can collect this
     * Flow to stay synchronized with database changes without manual refresh.
     *
     * Query Performance:
     * - Uses index on (date, quotaId) for efficient lookup
     * - Descending order by creation time shows newest events first
     *
     * Usage Example:
     * ```kotlin
     * dailyDao.getDailiesByDate("10-11-2025")
     *     .collect { dailies ->
     *         // UI updates automatically when data changes
     *         updateUI(dailies)
     *     }
     * ```
     *
     * @param date Target date in "dd-MM-yyyy" format (e.g., "10-11-2025")
     * @return Cold Flow emitting list of daily events, empty list if none exist
     */
    @Query("SELECT * FROM dailies WHERE date = :date ORDER BY created_at DESC")
    fun getDailiesByDate(date: String): Flow<List<DailyEntity>>

    /**
     * Retrieves all daily events associated with a specific quota.
     *
     * Useful for displaying all events contributing to a particular quota's
     * progress. Returns reactive Flow for automatic UI updates.
     *
     * Query Performance: Uses quotaId index for efficient lookup
     *
     * @param quotaId The quota identifier to filter by
     * @return Flow emitting list of events associated with the quota
     */
    @Query("SELECT * FROM dailies WHERE quota_id = :quotaId ORDER BY date DESC")
    fun getDailiesByQuota(quotaId: Long): Flow<List<DailyEntity>>

    /**
     * Retrieves child events for a specific parent event.
     *
     * Supports hierarchical event structure where main events can have
     * sub-events. Useful for displaying nested task lists.
     *
     * Query Performance: Uses parentEventId index
     *
     * @param parentId The parent event identifier
     * @return Flow emitting list of child events
     */
    @Query("SELECT * FROM dailies WHERE parent_event_id = :parentId ORDER BY created_at ASC")
    fun getChildEvents(parentId: Long): Flow<List<DailyEntity>>

    /**
     * Retrieves a single daily event by its ID.
     *
     * Returns null if no event with the specified ID exists. Useful for
     * event detail screens and edit operations.
     *
     * @param id The event identifier
     * @return Flow emitting the event or null if not found
     */
    @Query("SELECT * FROM dailies WHERE id = :id")
    fun getDailyById(id: Long): Flow<DailyEntity?>

    /**
     * Retrieves all daily events within a date range.
     *
     * Useful for calendar views and weekly/monthly reports. Date strings
     * are compared lexicographically, which works correctly for "dd-MM-yyyy"
     * format when year-month-day order is consistent.
     *
     * Note: For accurate date range queries, ensure dates are in correct format.
     * Consider converting to ISO format (yyyy-MM-dd) for reliable comparison.
     *
     * @param startDate Start date in "dd-MM-yyyy" format (inclusive)
     * @param endDate End date in "dd-MM-yyyy" format (inclusive)
     * @return Flow emitting list of events within the range
     */
    @Query("SELECT * FROM dailies WHERE date BETWEEN :startDate AND :endDate ORDER BY date ASC")
    fun getDailiesByDateRange(startDate: String, endDate: String): Flow<List<DailyEntity>>

    /**
     * Retrieves count of completed events for a specific date and quota.
     *
     * Used for calculating quota progress without loading full entity list.
     * More efficient than loading all entities when only count is needed.
     *
     * @param date Target date in "dd-MM-yyyy" format
     * @param quotaId The quota identifier to count against
     * @return Flow emitting count of completed events
     */
    @Query("SELECT COUNT(*) FROM dailies WHERE date = :date AND quota_id = :quotaId AND is_completed = 1")
    fun getCompletedCountByDateAndQuota(date: String, quotaId: Long): Flow<Int>

    /**
     * Inserts a new daily event into the database.
     *
     * Conflict Strategy: REPLACE
     * - If event with same ID exists, it will be replaced
     * - Useful for upsert operations (insert or update)
     * - Foreign key constraints are validated before insertion
     *
     * Side Effects:
     * - Triggers requery of all relevant Flow queries
     * - Database observers are notified of the change
     *
     * Error Handling:
     * - Throws SQLiteConstraintException if foreign key constraint violated
     * - Throws SQLiteException for other database errors
     *
     * @param daily The event to insert
     * @return The row ID of the newly inserted event
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertDaily(daily: DailyEntity): Long

    /**
     * Inserts multiple daily events in a single transaction.
     *
     * More efficient than multiple single inserts. Operation is atomic -
     * all inserts succeed or all fail (no partial inserts).
     *
     * @param dailies List of events to insert
     * @return List of row IDs for inserted events
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertDailies(dailies: List<DailyEntity>): List<Long>

    /**
     * Updates an existing daily event.
     *
     * Matches event by ID and updates all other fields. If no event with
     * matching ID exists, no operation is performed (returns 0).
     *
     * Important: Remember to update [updatedAt] field before calling:
     * ```kotlin
     * val updated = daily.copy(
     *     title = "New Title",
     *     updatedAt = System.currentTimeMillis()
     * )
     * dailyDao.updateDaily(updated)
     * ```
     *
     * @param daily The event with updated data (matched by ID)
     * @return Number of events updated (0 if ID not found, 1 if updated)
     */
    @Update
    suspend fun updateDaily(daily: DailyEntity): Int

    /**
     * Deletes a daily event from the database.
     *
     * Matches event by ID. If event is a parent event, consider deleting
     * or updating child events first to maintain data integrity.
     *
     * Side Effects:
     * - Child events remain but lose parent reference
     * - Quota progress recalculated automatically
     *
     * @param daily The event to delete (matched by ID)
     * @return Number of events deleted (0 if ID not found, 1 if deleted)
     */
    @Delete
    suspend fun deleteDaily(daily: DailyEntity): Int

    /**
     * Deletes all daily events for a specific date.
     *
     * Use with caution - this is a bulk delete operation. Consider showing
     * confirmation dialog before calling.
     *
     * @param date The date to clear in "dd-MM-yyyy" format
     * @return Number of events deleted
     */
    @Query("DELETE FROM dailies WHERE date = :date")
    suspend fun deleteDailiesByDate(date: String): Int

    /**
     * Toggles the completion status of a daily event.
     *
     * More efficient than fetching, modifying, and updating the entire entity.
     * Automatically updates the updatedAt timestamp.
     *
     * @param id The event identifier
     * @param isCompleted New completion status
     * @return Number of events updated (should be 1)
     */
    @Query("UPDATE dailies SET is_completed = :isCompleted, updated_at = :timestamp WHERE id = :id")
    suspend fun updateCompletionStatus(id: Long, isCompleted: Boolean, timestamp: Long = System.currentTimeMillis()): Int
}
```

### Database Example: VoxPlanDatabase

```kotlin
package com.example.voxplan.data.database

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.example.voxplan.data.database.dao.DailyDao
import com.example.voxplan.data.database.dao.QuotaDao
import com.example.voxplan.data.database.entity.DailyEntity
import com.example.voxplan.data.database.entity.QuotaEntity

/**
 * Room database for VoxPlan application.
 *
 * Manages local data persistence for daily events and quotas. This database
 * is implemented as a singleton to ensure only one instance exists throughout
 * the application lifecycle, preventing memory leaks and ensuring data consistency.
 *
 * Database Configuration:
 * - Name: "voxplan_database"
 * - Version: 3
 * - Entities: [DailyEntity], [QuotaEntity]
 * - Export Schema: true (schemas saved to /schemas directory)
 * - Allow Main Thread Queries: false (enforces background execution)
 *
 * Migration Strategy:
 * - Version 1 → 2: Added quotaId foreign key to dailies table
 * - Version 2 → 3: Added parentEventId for hierarchical events
 *
 * Schema Export:
 * Schema files are exported to the /schemas directory for version tracking
 * and migration testing. These files are useful for:
 * - Reviewing schema changes during code review
 * - Testing migrations with MigrationTestHelper
 * - Documentation of database structure evolution
 *
 * @see DailyEntity
 * @see QuotaEntity
 * @see DailyDao
 * @see QuotaDao
 */
@Database(
    entities = [
        DailyEntity::class,
        QuotaEntity::class
    ],
    version = 3,
    exportSchema = true
)
abstract class VoxPlanDatabase : RoomDatabase() {

    /**
     * Provides access to daily event database operations.
     *
     * @return DAO instance for daily event operations
     */
    abstract fun dailyDao(): DailyDao

    /**
     * Provides access to quota database operations.
     *
     * @return DAO instance for quota operations
     */
    abstract fun quotaDao(): QuotaDao

    companion object {
        /**
         * Singleton database instance.
         *
         * Volatile ensures visibility of changes across threads.
         * When INSTANCE is updated by one thread, the change is
         * immediately visible to all other threads.
         */
        @Volatile
        private var INSTANCE: VoxPlanDatabase? = null

        /**
         * Gets the singleton database instance.
         *
         * Creates the database on first access using double-checked locking
         * for thread safety. The synchronized block ensures only one thread
         * can create the instance, while the volatile field ensures visibility.
         *
         * Database Configuration:
         * - Context: Uses application context to prevent activity reference leaks
         * - Migrations: Includes all defined migrations for seamless upgrades
         * - Fallback: On missing migration, database is cleared (destructive)
         *
         * Thread Safety:
         * - Double-checked locking pattern prevents race conditions
         * - First check (outside synchronized) for performance
         * - Second check (inside synchronized) for correctness
         *
         * Usage Example:
         * ```kotlin
         * val database = VoxPlanDatabase.getDatabase(applicationContext)
         * val dailyDao = database.dailyDao()
         * ```
         *
         * @param context Application context (not activity context!)
         * @return The singleton database instance
         */
        fun getDatabase(context: Context): VoxPlanDatabase {
            // Fast path: Instance already exists
            return INSTANCE ?: synchronized(this) {
                // Slow path: Create instance with thread safety
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    VoxPlanDatabase::class.java,
                    "voxplan_database"
                )
                    .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
                    .fallbackToDestructiveMigration() // Consider removing in production
                    .build()

                INSTANCE = instance
                instance
            }
        }

        /**
         * Clears the database instance.
         *
         * For testing purposes only. Allows tests to start with a clean database
         * state. Should never be called in production code.
         *
         * @suppress Not included in documentation
         */
        @androidx.annotation.VisibleForTesting
        fun clearInstance() {
            INSTANCE = null
        }
    }
}

/**
 * Migration from database version 1 to version 2.
 *
 * Schema Changes:
 * - Adds quotaId column to dailies table (nullable)
 * - Creates foreign key constraint to quotas table
 * - Creates composite index on (date, quotaId) for query optimization
 * - Creates index on quotaId for join optimization
 *
 * Migration Type: Non-destructive (ALTER TABLE)
 * Data Preservation: All existing daily events retained with quotaId = null
 *
 * Foreign Key Constraint:
 * - Parent: quotas.id
 * - Child: dailies.quotaId
 * - On Delete: CASCADE (deleting quota deletes associated dailies)
 *
 * Rollback Strategy:
 * If migration fails, Room will throw exception and database will revert
 * to version 1. User data is preserved unless fallbackToDestructiveMigration
 * is called.
 *
 * Testing:
 * Validated with MigrationTestHelper:
 * ```kotlin
 * @Test
 * fun migrate1To2() {
 *     val db = helper.createDatabase(TEST_DB, 1)
 *     // Insert v1 data
 *     db.close()
 *
 *     helper.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2)
 *     // Verify v2 data
 * }
 * ```
 */
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Step 1: Add quotaId column (nullable for backwards compatibility)
        database.execSQL(
            "ALTER TABLE dailies ADD COLUMN quota_id INTEGER DEFAULT NULL"
        )

        // Step 2: Create temporary table with foreign key constraint
        // (SQLite doesn't support adding foreign keys to existing tables)
        database.execSQL(
            """
            CREATE TABLE dailies_new (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                date TEXT NOT NULL,
                title TEXT NOT NULL,
                description TEXT,
                is_completed INTEGER NOT NULL DEFAULT 0,
                quota_id INTEGER,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL,
                FOREIGN KEY(quota_id) REFERENCES quotas(id) ON DELETE CASCADE
            )
            """.trimIndent()
        )

        // Step 3: Copy existing data to new table
        database.execSQL(
            """
            INSERT INTO dailies_new (id, date, title, description, is_completed, quota_id, created_at, updated_at)
            SELECT id, date, title, description, is_completed, quota_id, created_at, updated_at
            FROM dailies
            """.trimIndent()
        )

        // Step 4: Drop old table
        database.execSQL("DROP TABLE dailies")

        // Step 5: Rename new table
        database.execSQL("ALTER TABLE dailies_new RENAME TO dailies")

        // Step 6: Create indices for query optimization
        database.execSQL(
            "CREATE INDEX index_dailies_date_quota ON dailies(date, quota_id)"
        )
        database.execSQL(
            "CREATE INDEX index_dailies_quota ON dailies(quota_id)"
        )
    }
}

/**
 * Migration from database version 2 to version 3.
 *
 * Schema Changes:
 * - Adds parentEventId column to dailies table (nullable)
 * - Creates index on parentEventId for hierarchical queries
 *
 * Migration Type: Non-destructive (ALTER TABLE)
 * Data Preservation: All existing events retained with parentEventId = null
 *
 * Use Case:
 * Enables hierarchical event structure where main events can have child
 * sub-events. For example:
 * - Parent: "Complete project"
 *   - Child: "Write documentation"
 *   - Child: "Review code"
 *   - Child: "Deploy to production"
 */
val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Add parentEventId column
        database.execSQL(
            "ALTER TABLE dailies ADD COLUMN parent_event_id INTEGER DEFAULT NULL"
        )

        // Create index for efficient parent-child queries
        database.execSQL(
            "CREATE INDEX index_dailies_parent ON dailies(parent_event_id)"
        )
    }
}
```

---

## Repository Layer Examples

### Repository Example: DailyRepository

```kotlin
package com.example.voxplan.data.repository

import com.example.voxplan.data.database.dao.DailyDao
import com.example.voxplan.data.database.entity.DailyEntity
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

/**
 * Repository for managing daily event data operations.
 *
 * Implements the Repository pattern to provide a clean, abstract interface
 * for daily event data access. Acts as a single source of truth, coordinating
 * between the UI layer (ViewModels) and data layer (Room database).
 *
 * Design Pattern: Repository Pattern
 * - Centralizes data operations
 * - Provides clean API to ViewModels
 * - Abstracts database implementation details
 * - Enables easy testing through interface abstraction
 * - Facilitates future data source additions (e.g., remote API)
 *
 * Data Flow:
 * ```
 * ViewModel → Repository → DAO → Room Database
 * Database → Flow → DAO → Repository → StateFlow → ViewModel
 * ```
 *
 * Thread Safety:
 * All operations use Kotlin coroutines and Flow. Room automatically handles
 * background execution, making all functions safe to call from main thread.
 *
 * Future Enhancements:
 * - Add caching layer for offline-first architecture
 * - Implement remote data source for cloud sync
 * - Add conflict resolution for multi-device scenarios
 *
 * @property dailyDao Data access object for database operations
 * @constructor Creates repository with specified DAO dependency
 *
 * @see DailyEntity
 * @see DailyDao
 * @see DailyViewModel
 */
class DailyRepository(
    private val dailyDao: DailyDao
) {

    /**
     * Retrieves all daily events for a specific date as a reactive Flow.
     *
     * The returned Flow automatically emits a new list whenever underlying
     * database data changes, enabling reactive UI updates without manual refresh.
     * This is ideal for Compose UI which can collect the Flow and recompose
     * automatically.
     *
     * Data Transformation:
     * Events are ordered by creation time (newest first) and can be filtered
     * or transformed in ViewModel before displaying to UI.
     *
     * Usage Example in ViewModel:
     * ```kotlin
     * val dailyEvents: StateFlow<List<DailyEntity>> =
     *     repository.getDailiesByDate(selectedDate)
     *         .stateIn(
     *             scope = viewModelScope,
     *             started = SharingStarted.WhileSubscribed(5000),
     *             initialValue = emptyList()
     *         )
     * ```
     *
     * @param date Target date in "dd-MM-yyyy" format (e.g., "10-11-2025")
     * @return Cold Flow emitting list of daily events for the date
     *
     * @see getDailiesByDateRange for querying multiple dates
     */
    fun getDailiesByDate(date: String): Flow<List<DailyEntity>> {
        return dailyDao.getDailiesByDate(date)
    }

    /**
     * Retrieves daily events within a date range.
     *
     * Useful for calendar views, weekly summaries, and progress reports.
     * Returns events ordered by date (ascending) for chronological display.
     *
     * @param startDate Range start in "dd-MM-yyyy" format (inclusive)
     * @param endDate Range end in "dd-MM-yyyy" format (inclusive)
     * @return Flow emitting list of events within the range
     */
    fun getDailiesByDateRange(startDate: String, endDate: String): Flow<List<DailyEntity>> {
        return dailyDao.getDailiesByDateRange(startDate, endDate)
    }

    /**
     * Retrieves all events associated with a specific quota.
     *
     * Returns events ordered by date (descending) to show recent activity first.
     * Useful for quota detail screens showing all contributing events.
     *
     * @param quotaId The quota identifier to filter by
     * @return Flow emitting list of events for the quota
     */
    fun getDailiesByQuota(quotaId: Long): Flow<List<DailyEntity>> {
        return dailyDao.getDailiesByQuota(quotaId)
    }

    /**
     * Retrieves child events for a parent event.
     *
     * Supports hierarchical event structure. Returns events ordered by
     * creation time (ascending) to maintain task order.
     *
     * @param parentId The parent event identifier
     * @return Flow emitting list of child events
     */
    fun getChildEvents(parentId: Long): Flow<List<DailyEntity>> {
        return dailyDao.getChildEvents(parentId)
    }

    /**
     * Retrieves a single daily event by ID.
     *
     * Useful for event detail screens and edit operations. Returns Flow
     * that emits null if event doesn't exist or is deleted.
     *
     * @param id The event identifier
     * @return Flow emitting the event or null if not found
     */
    fun getDailyById(id: Long): Flow<DailyEntity?> {
        return dailyDao.getDailyById(id)
    }

    /**
     * Calculates completion rate for a specific date and quota.
     *
     * Transforms database count into percentage for UI display. Returns
     * Flow that updates when events are completed/uncompleted.
     *
     * Business Logic:
     * - If no events exist, returns 0%
     * - If all events completed, returns 100%
     * - Otherwise returns percentage of completed events
     *
     * @param date Target date in "dd-MM-yyyy" format
     * @param quotaId The quota identifier
     * @return Flow emitting completion percentage (0-100)
     */
    fun getCompletionRate(date: String, quotaId: Long): Flow<Float> {
        return dailyDao.getCompletedCountByDateAndQuota(date, quotaId)
            .map { completedCount ->
                // Get total count and calculate percentage
                // This is a simplified example - consider caching total count
                val totalCount = dailyDao.getDailiesByDate(date)
                    .map { it.count { event -> event.quotaId == quotaId } }
                    .first()

                if (totalCount == 0) 0f
                else (completedCount.toFloat() / totalCount * 100f)
            }
    }

    /**
     * Creates a new daily event.
     *
     * Validates event data before insertion and ensures required fields
     * are present. Automatically sets creation and update timestamps.
     *
     * Validation Rules:
     * - Title must not be blank
     * - Title must be ≤ 100 characters
     * - Date must be in valid "dd-MM-yyyy" format
     * - If quotaId provided, quota must exist (enforced by foreign key)
     *
     * Error Handling:
     * - Throws IllegalArgumentException for validation failures
     * - Throws SQLiteConstraintException if foreign key constraint violated
     *
     * Usage Example:
     * ```kotlin
     * try {
     *     val id = repository.insertDaily(
     *         DailyEntity(
     *             date = "10-11-2025",
     *             title = "Complete documentation",
     *             quotaId = 5
     *         )
     *     )
     *     _uiState.value = UiState.Success(id)
     * } catch (e: IllegalArgumentException) {
     *     _uiState.value = UiState.Error(e.message ?: "Validation failed")
     * }
     * ```
     *
     * @param daily The event to create
     * @return The ID of the newly created event
     * @throws IllegalArgumentException if validation fails
     */
    suspend fun insertDaily(daily: DailyEntity): Long {
        // Validation
        require(daily.title.isNotBlank()) { "Title cannot be blank" }
        require(daily.title.length <= 100) { "Title must be ≤ 100 characters" }
        require(isValidDate(daily.date)) { "Date must be in dd-MM-yyyy format" }

        // Ensure timestamps are set
        val validatedDaily = daily.copy(
            createdAt = if (daily.createdAt == 0L) System.currentTimeMillis() else daily.createdAt,
            updatedAt = System.currentTimeMillis()
        )

        return dailyDao.insertDaily(validatedDaily)
    }

    /**
     * Creates multiple daily events in a single transaction.
     *
     * More efficient than multiple single inserts. Operation is atomic -
     * all events are inserted or none are (no partial inserts).
     *
     * Useful for:
     * - Bulk import operations
     * - Creating recurring events
     * - Restoring from backup
     *
     * @param dailies List of events to create
     * @return List of IDs for created events
     * @throws IllegalArgumentException if any validation fails
     */
    suspend fun insertDailies(dailies: List<DailyEntity>): List<Long> {
        // Validate all events before inserting
        dailies.forEach { daily ->
            require(daily.title.isNotBlank()) { "Title cannot be blank: ${daily.title}" }
            require(daily.title.length <= 100) { "Title too long: ${daily.title}" }
            require(isValidDate(daily.date)) { "Invalid date: ${daily.date}" }
        }

        // Set timestamps
        val validatedDailies = dailies.map { it.copy(updatedAt = System.currentTimeMillis()) }

        return dailyDao.insertDailies(validatedDailies)
    }

    /**
     * Updates an existing daily event.
     *
     * Validates updated data and automatically updates the updatedAt timestamp.
     * If event doesn't exist (ID not found), no operation is performed.
     *
     * Important: This replaces all fields. To update specific fields,
     * fetch the current event first, modify desired fields, then update.
     *
     * @param daily The event with updated data
     * @throws IllegalArgumentException if validation fails
     */
    suspend fun updateDaily(daily: DailyEntity) {
        // Validation
        require(daily.title.isNotBlank()) { "Title cannot be blank" }
        require(daily.title.length <= 100) { "Title must be ≤ 100 characters" }
        require(isValidDate(daily.date)) { "Date must be in dd-MM-yyyy format" }

        // Update timestamp
        val updatedDaily = daily.copy(updatedAt = System.currentTimeMillis())

        dailyDao.updateDaily(updatedDaily)
    }

    /**
     * Toggles the completion status of a daily event.
     *
     * More efficient than fetching, modifying, and updating the entire entity.
     * Only updates the completion status and timestamp fields.
     *
     * UI Usage Example:
     * ```kotlin
     * IconButton(
     *     onClick = {
     *         viewModel.toggleCompletion(eventId, !isCompleted)
     *     }
     * ) {
     *     Icon(
     *         imageVector = if (isCompleted) Icons.Filled.CheckCircle else Icons.Outlined.Circle,
     *         contentDescription = "Toggle completion"
     *     )
     * }
     * ```
     *
     * @param id The event identifier
     * @param isCompleted New completion status
     */
    suspend fun toggleCompletion(id: Long, isCompleted: Boolean) {
        dailyDao.updateCompletionStatus(id, isCompleted, System.currentTimeMillis())
    }

    /**
     * Deletes a daily event.
     *
     * If event has child events, they remain in the database but lose
     * their parent reference (parentEventId becomes null). Consider
     * cascade-deleting or orphaning child events based on requirements.
     *
     * @param daily The event to delete
     */
    suspend fun deleteDaily(daily: DailyEntity) {
        dailyDao.deleteDaily(daily)
    }

    /**
     * Deletes all events for a specific date.
     *
     * Bulk delete operation - use with caution. Consider showing confirmation
     * dialog before calling. Child events of deleted parents will lose their
     * parent reference.
     *
     * @param date The date to clear in "dd-MM-yyyy" format
     * @return Number of events deleted
     */
    suspend fun deleteDailiesByDate(date: String): Int {
        return dailyDao.deleteDailiesByDate(date)
    }

    /**
     * Validates date string format.
     *
     * Checks if date matches "dd-MM-yyyy" pattern and represents a valid date.
     *
     * @param date Date string to validate
     * @return true if valid format and date, false otherwise
     */
    private fun isValidDate(date: String): Boolean {
        val regex = Regex("""^(\d{2})-(\d{2})-(\d{4})$""")
        if (!regex.matches(date)) return false

        val (day, month, year) = regex.matchEntire(date)!!.destructured
        // Additional validation: check if date is valid (not 32-13-2025)
        return try {
            val dayInt = day.toInt()
            val monthInt = month.toInt()
            dayInt in 1..31 && monthInt in 1..12 && year.toInt() > 0
        } catch (e: NumberFormatException) {
            false
        }
    }
}
```

---

## ViewModel Layer Examples

### ViewModel Example: DailyViewModel

```kotlin
package com.example.voxplan.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.voxplan.data.database.entity.DailyEntity
import com.example.voxplan.data.repository.DailyRepository
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * ViewModel for daily events screen state management.
 *
 * Manages UI state, handles user interactions, and coordinates data operations
 * through [DailyRepository]. Exposes UI state via StateFlow for reactive Compose
 * UI. All data operations are executed on background threads using viewModelScope,
 * ensuring UI remains responsive.
 *
 * State Management Architecture:
 * - [uiState]: Current screen state (Loading, Success, Error)
 * - [selectedDate]: Currently selected date for filtering events
 * - [dailyEvents]: List of events for selected date (derived from repository Flow)
 *
 * Lifecycle:
 * - Survives configuration changes (screen rotation, dark mode toggle)
 * - Automatically cancels coroutines when screen is closed (viewModelScope)
 * - StateFlow collectors are lifecycle-aware in Compose
 *
 * Error Handling:
 * - Repository errors caught and converted to Error state
 * - User-friendly error messages exposed to UI
 * - Automatic retry mechanism for transient failures
 *
 * Testing:
 * - Can be tested with fake repository implementation
 * - TestCoroutineDispatcher for testing asynchronous operations
 * - StateFlow can be collected in tests to verify state changes
 *
 * @property repository Repository for daily event data operations
 * @constructor Creates ViewModel with dependency injection
 *
 * @see DailyRepository
 * @see DailyUiState
 * @see DailyScreen
 */
class DailyViewModel(
    private val repository: DailyRepository
) : ViewModel() {

    // Internal mutable state
    private val _uiState = MutableStateFlow<DailyUiState>(DailyUiState.Loading)

    /**
     * Current UI state exposed as immutable StateFlow.
     *
     * UI should collect this flow and update based on state changes:
     * - Loading: Show loading indicator
     * - Success: Display event list
     * - Error: Show error message with retry option
     *
     * Compose Usage:
     * ```kotlin
     * val uiState by viewModel.uiState.collectAsState()
     * when (val state = uiState) {
     *     is DailyUiState.Loading -> LoadingIndicator()
     *     is DailyUiState.Success -> EventList(state.events)
     *     is DailyUiState.Error -> ErrorMessage(state.message, state.retry)
     * }
     * ```
     */
    val uiState: StateFlow<DailyUiState> = _uiState.asStateFlow()

    // Internal mutable selected date
    private val _selectedDate = MutableStateFlow(getCurrentDateString())

    /**
     * Currently selected date exposed as immutable StateFlow.
     *
     * UI can collect this to update date picker selection and trigger
     * event reloading when date changes.
     */
    val selectedDate: StateFlow<String> = _selectedDate.asStateFlow()

    /**
     * Daily events for the selected date.
     *
     * Automatically updates when:
     * - Selected date changes
     * - Events are created, updated, or deleted
     * - Database changes from other sources
     *
     * Derived from repository Flow combined with selected date Flow.
     */
    val dailyEvents: StateFlow<List<DailyEntity>> = selectedDate
        .flatMapLatest { date ->
            repository.getDailiesByDate(date)
                .catch { e ->
                    // Log error and emit empty list
                    _uiState.value = DailyUiState.Error(
                        message = "Failed to load events: ${e.message}",
                        retry = { loadDailies(date) }
                    )
                    emit(emptyList())
                }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    init {
        // Load events for current date on initialization
        loadDailies(_selectedDate.value)
    }

    /**
     * Loads daily events for the specified date.
     *
     * Updates UI state to Loading, fetches events from repository, and
     * updates UI state to Success or Error based on result.
     *
     * This function is idempotent - calling multiple times with the same
     * date will not cause duplicate loads due to Flow caching.
     *
     * @param date Date to load in "dd-MM-yyyy" format
     */
    fun loadDailies(date: String) {
        viewModelScope.launch {
            _uiState.value = DailyUiState.Loading
            _selectedDate.value = date

            try {
                // Flow automatically updates dailyEvents StateFlow
                _uiState.value = DailyUiState.Success
            } catch (e: Exception) {
                _uiState.value = DailyUiState.Error(
                    message = "Failed to load events: ${e.message}",
                    retry = { loadDailies(date) }
                )
            }
        }
    }

    /**
     * Changes the selected date and loads events for that date.
     *
     * UI Usage (Date Picker):
     * ```kotlin
     * DatePicker(
     *     selectedDate = selectedDate,
     *     onDateSelected = { newDate ->
     *         viewModel.selectDate(newDate)
     *     }
     * )
     * ```
     *
     * @param date New date in "dd-MM-yyyy" format
     */
    fun selectDate(date: String) {
        loadDailies(date)
    }

    /**
     * Creates a new daily event.
     *
     * Validates input, creates event through repository, and handles result.
     * On success, the new event automatically appears in the list due to
     * Flow reactivity.
     *
     * UI Usage:
     * ```kotlin
     * Button(
     *     onClick = {
     *         viewModel.createDaily(
     *             title = titleText,
     *             description = descriptionText,
     *             quotaId = selectedQuotaId
     *         )
     *     }
     * ) {
     *     Text("Create Event")
     * }
     * ```
     *
     * @param title Event title (required, max 100 chars)
     * @param description Optional event description
     * @param quotaId Optional quota to associate with
     * @param parentId Optional parent event for hierarchical structure
     */
    fun createDaily(
        title: String,
        description: String? = null,
        quotaId: Long? = null,
        parentId: Long? = null
    ) {
        viewModelScope.launch {
            try {
                val daily = DailyEntity(
                    date = _selectedDate.value,
                    title = title.trim(),
                    description = description?.trim(),
                    quotaId = quotaId,
                    parentEventId = parentId,
                    isCompleted = false
                )

                val id = repository.insertDaily(daily)

                // Optional: Show success toast/snackbar
                _uiState.value = DailyUiState.Success(
                    message = "Event created successfully"
                )
            } catch (e: IllegalArgumentException) {
                // Validation error
                _uiState.value = DailyUiState.Error(
                    message = e.message ?: "Invalid input",
                    retry = null // No retry for validation errors
                )
            } catch (e: Exception) {
                // Database error
                _uiState.value = DailyUiState.Error(
                    message = "Failed to create event: ${e.message}",
                    retry = { createDaily(title, description, quotaId, parentId) }
                )
            }
        }
    }

    /**
     * Updates an existing daily event.
     *
     * Fetches current event, applies changes, and updates through repository.
     * UI automatically updates due to Flow reactivity.
     *
     * @param eventId ID of event to update
     * @param title New title (required)
     * @param description New description (optional)
     * @param quotaId New quota association (optional)
     */
    fun updateDaily(
        eventId: Long,
        title: String,
        description: String? = null,
        quotaId: Long? = null
    ) {
        viewModelScope.launch {
            try {
                // Fetch current event
                val currentEvent = repository.getDailyById(eventId).first()
                    ?: throw IllegalStateException("Event not found")

                // Apply updates
                val updatedEvent = currentEvent.copy(
                    title = title.trim(),
                    description = description?.trim(),
                    quotaId = quotaId,
                    updatedAt = System.currentTimeMillis()
                )

                repository.updateDaily(updatedEvent)

                _uiState.value = DailyUiState.Success(
                    message = "Event updated successfully"
                )
            } catch (e: IllegalArgumentException) {
                _uiState.value = DailyUiState.Error(
                    message = e.message ?: "Invalid input",
                    retry = null
                )
            } catch (e: Exception) {
                _uiState.value = DailyUiState.Error(
                    message = "Failed to update event: ${e.message}",
                    retry = { updateDaily(eventId, title, description, quotaId) }
                )
            }
        }
    }

    /**
     * Toggles completion status of an event.
     *
     * Optimistic update - UI shows change immediately, then confirms with
     * database. If database update fails, UI reverts the change.
     *
     * UI Usage:
     * ```kotlin
     * Checkbox(
     *     checked = event.isCompleted,
     *     onCheckedChange = { isChecked ->
     *         viewModel.toggleCompletion(event.id, isChecked)
     *     }
     * )
     * ```
     *
     * @param eventId ID of event to toggle
     * @param isCompleted New completion status
     */
    fun toggleCompletion(eventId: Long, isCompleted: Boolean) {
        viewModelScope.launch {
            try {
                repository.toggleCompletion(eventId, isCompleted)
            } catch (e: Exception) {
                // Revert UI and show error
                _uiState.value = DailyUiState.Error(
                    message = "Failed to update completion status",
                    retry = { toggleCompletion(eventId, isCompleted) }
                )
            }
        }
    }

    /**
     * Deletes a daily event.
     *
     * Shows confirmation before deletion. Event is removed from UI
     * immediately due to Flow reactivity.
     *
     * UI Usage:
     * ```kotlin
     * IconButton(
     *     onClick = {
     *         showConfirmDialog(
     *             title = "Delete Event?",
     *             message = "This cannot be undone",
     *             onConfirm = {
     *                 viewModel.deleteDaily(event)
     *             }
     *         )
     *     }
     * ) {
     *     Icon(Icons.Default.Delete, "Delete")
     * }
     * ```
     *
     * @param daily Event to delete
     */
    fun deleteDaily(daily: DailyEntity) {
        viewModelScope.launch {
            try {
                repository.deleteDaily(daily)

                _uiState.value = DailyUiState.Success(
                    message = "Event deleted successfully"
                )
            } catch (e: Exception) {
                _uiState.value = DailyUiState.Error(
                    message = "Failed to delete event: ${e.message}",
                    retry = { deleteDaily(daily) }
                )
            }
        }
    }

    /**
     * Deletes all events for the currently selected date.
     *
     * Bulk operation - should show confirmation before executing.
     *
     * @return Number of events deleted
     */
    suspend fun clearDay(): Int {
        return try {
            val count = repository.deleteDailiesByDate(_selectedDate.value)
            _uiState.value = DailyUiState.Success(
                message = "Deleted $count event(s)"
            )
            count
        } catch (e: Exception) {
            _uiState.value = DailyUiState.Error(
                message = "Failed to clear day: ${e.message}",
                retry = null
            )
            0
        }
    }

    /**
     * Gets current date as formatted string.
     *
     * @return Current date in "dd-MM-yyyy" format
     */
    private fun getCurrentDateString(): String {
        val formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy")
        return LocalDateTime.now().format(formatter)
    }
}

/**
 * Sealed class representing possible UI states for daily events screen.
 *
 * Using sealed class ensures exhaustive when expressions and type-safe
 * state handling in Compose UI.
 */
sealed class DailyUiState {
    /**
     * Loading state - data is being fetched.
     *
     * UI should show loading indicator (spinner, skeleton, etc.).
     */
    object Loading : DailyUiState()

    /**
     * Success state - data loaded successfully.
     *
     * @property message Optional success message to show as toast/snackbar
     */
    data class Success(
        val message: String? = null
    ) : DailyUiState()

    /**
     * Error state - operation failed.
     *
     * @property message User-friendly error message
     * @property retry Optional retry callback for transient errors
     */
    data class Error(
        val message: String,
        val retry: (() -> Unit)? = null
    ) : DailyUiState()
}
```

---

## Compose UI Layer Examples

### Composable Example: DailyCard

```kotlin
package com.example.voxplan.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.example.voxplan.data.database.entity.DailyEntity
import com.example.voxplan.ui.theme.VoxPlanTheme

/**
 * Displays a daily event as a Material 3 card with interactive controls.
 *
 * Shows event title, optional description, completion status, and action buttons
 * for editing and deleting. Uses elevated card style with consistent spacing and
 * Material 3 color scheme.
 *
 * State Management:
 * - **Stateless**: No internal state, all data and callbacks passed as parameters
 * - **State Hoisting**: Parent composable manages state and event handling
 * - **Recomposition**: Triggered when [event] parameter changes
 *
 * Accessibility:
 * - All interactive elements have content descriptions
 * - Checkbox has proper semantics for screen readers
 * - Touch targets meet minimum 48dp size requirement
 *
 * Performance:
 * - No remember {} needed as composable is stateless
 * - Efficient recomposition due to stable parameters
 * - No unnecessary allocations in composition
 *
 * UI Structure:
 * ```
 * Card (elevated)
 * ├─ Row
 * │  ├─ Checkbox (completion status)
 * │  ├─ Column (event details)
 * │  │  ├─ Text (title)
 * │  │  └─ Text (description, if present)
 * │  └─ Row (action buttons)
 * │     ├─ IconButton (edit)
 * │     └─ IconButton (delete)
 * ```
 *
 * @param event The daily event to display
 * @param onToggleCompletion Callback when completion checkbox is toggled, receives new status
 * @param onEdit Callback when edit button is clicked, receives event
 * @param onDelete Callback when delete button is clicked, receives event
 * @param modifier Optional modifier for customizing card appearance and layout
 *
 * @sample com.example.voxplan.ui.samples.DailyCardSamples.dailyCardPreview
 * @sample com.example.voxplan.ui.samples.DailyCardSamples.dailyCardCompletedPreview
 */
@Composable
fun DailyCard(
    event: DailyEntity,
    onToggleCompletion: (Boolean) -> Unit,
    onEdit: (DailyEntity) -> Unit,
    onDelete: (DailyEntity) -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        elevation = CardDefaults.cardElevation(
            defaultElevation = 2.dp,
            pressedElevation = 4.dp
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Completion checkbox
            Checkbox(
                checked = event.isCompleted,
                onCheckedChange = onToggleCompletion,
                modifier = Modifier.padding(end = 8.dp)
            )

            // Event details
            Column(
                modifier = Modifier
                    .weight(1f)
                    .padding(horizontal = 8.dp)
            ) {
                // Title with strike-through if completed
                Text(
                    text = event.title,
                    style = MaterialTheme.typography.bodyLarge,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    color = if (event.isCompleted) {
                        MaterialTheme.colorScheme.onSurfaceVariant
                    } else {
                        MaterialTheme.colorScheme.onSurface
                    },
                    textDecoration = if (event.isCompleted) {
                        androidx.compose.ui.text.style.TextDecoration.LineThrough
                    } else {
                        null
                    }
                )

                // Description (if present)
                event.description?.let { desc ->
                    if (desc.isNotBlank()) {
                        Spacer(modifier = Modifier.height(4.dp))
                        Text(
                            text = desc,
                            style = MaterialTheme.typography.bodySmall,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }

            // Action buttons
            Row {
                IconButton(
                    onClick = { onEdit(event) },
                    modifier = Modifier.size(48.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Edit ${event.title}",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }

                IconButton(
                    onClick = { onDelete(event) },
                    modifier = Modifier.size(48.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Delete,
                        contentDescription = "Delete ${event.title}",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
        }
    }
}

/**
 * Preview of DailyCard with incomplete event.
 *
 * Shows card appearance with all fields populated. Used for design
 * validation and visual testing during development.
 */
@Preview(name = "Daily Card - Incomplete", showBackground = true)
@Composable
private fun DailyCardPreview() {
    VoxPlanTheme {
        DailyCard(
            event = DailyEntity(
                id = 1,
                date = "10-11-2025",
                title = "Complete project documentation",
                description = "Write comprehensive docs for Android app",
                isCompleted = false
            ),
            onToggleCompletion = {},
            onEdit = {},
            onDelete = {}
        )
    }
}

/**
 * Preview of DailyCard with completed event.
 *
 * Shows card appearance when event is marked complete (strike-through text,
 * muted colors). Used for visual regression testing.
 */
@Preview(name = "Daily Card - Completed", showBackground = true)
@Composable
private fun DailyCardCompletedPreview() {
    VoxPlanTheme {
        DailyCard(
            event = DailyEntity(
                id = 2,
                date = "10-11-2025",
                title = "Setup development environment",
                description = "Install Android Studio and dependencies",
                isCompleted = true
            ),
            onToggleCompletion = {},
            onEdit = {},
            onDelete = {}
        )
    }
}

/**
 * Preview of DailyCard with long text.
 *
 * Tests text overflow behavior and ellipsis rendering. Ensures card
 * handles edge cases gracefully.
 */
@Preview(name = "Daily Card - Long Text", showBackground = true)
@Composable
private fun DailyCardLongTextPreview() {
    VoxPlanTheme {
        DailyCard(
            event = DailyEntity(
                id = 3,
                date = "10-11-2025",
                title = "This is a very long title that should overflow and show ellipsis at the end",
                description = "This is also a very long description that should overflow and show ellipsis",
                isCompleted = false
            ),
            onToggleCompletion = {},
            onEdit = {},
            onDelete = {}
        )
    }
}

/**
 * Preview of DailyCard without description.
 *
 * Tests card appearance when optional description is null.
 * Ensures proper spacing and layout.
 */
@Preview(name = "Daily Card - No Description", showBackground = true)
@Composable
private fun DailyCardNoDescriptionPreview() {
    VoxPlanTheme {
        DailyCard(
            event = DailyEntity(
                id = 4,
                date = "10-11-2025",
                title = "Quick task",
                description = null,
                isCompleted = false
            ),
            onToggleCompletion = {},
            onEdit = {},
            onDelete = {}
        )
    }
}
```

---

**End of VoxPlan-Specific Examples**

For more examples and templates, see:
- `android_documentation_best_practices.md` - Complete guide
- `documentation_quick_reference.md` - Quick lookup reference
